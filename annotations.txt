# config_avancada.json
{
    "source_directory": "/home/usuario/documentos",
    "local_backup_directory": "/media/backup_disk/backups",
    "cloud_provider": "google_drive",
    "cloud_directory": "/Backups/MeuPC",

    "backup_schedule": {
        "full_backup_interval_days": 7,
        "incremental_interval_hours": 6,
        "cloud_sync_interval_hours": 1,
        "cleanup_interval_days": 1
    },

    "retention_policy": {
        "keep_full_backups": 4,
        "keep_incremental_days": 30,
        "keep_cloud_backups": 8
    },

    "compression": {
        "enabled": true,
        "level": 6,
        "method": "zip"
    },

    "encryption": {
        "enabled": false,
        "password": "sua_senha_segura",
        "algorithm": "AES256"
    },

    "monitoring": {
        "enabled": true,
        "check_interval_minutes": 15,
        "system_thresholds": {
            "cpu_max": 90,
            "memory_max": 85,
            "disk_min_gb": 10
        }
    },

    "notifications": {
        "email": {
            "enabled": false,
            "smtp_server": "smtp.gmail.com",
            "smtp_port": 587,
            "username": "seu_email@gmail.com",
            "password": "sua_senha_app",
            "from": "backup@seudominio.com",
            "to": "admin@seudominio.com",
            "notify_on_success": false,
            "notify_on_error": true
        },
        "webhook": {
            "enabled": false,
            "url": "https://hooks.slack.com/services/SEU/WEBHOOK/URL",
            "notify_on_success": true,
            "notify_on_error": true
        }
    },

    "exclude_patterns": [
        "*.tmp", "*.log", "*.cache",
        "__pycache__", ".git", ".svn",
        "node_modules", "venv", ".env",
        "*.iso", "*.img", "*.vmdk",
        "Thumbs.db", ".DS_Store",
        "System Volume Information",
        "$RECYCLE.BIN"
    ],

    "include_patterns": [
        "*.doc", "*.docx", "*.pdf",
        "*.xls", "*.xlsx", "*.ppt", "*.pptx",
        "*.jpg", "*.png", "*.gif", "*.mp4",
        "*.txt", "*.rtf", "*.odt",
        "*.zip", "*.rar", "*.7z"
    ],

    "performance": {
        "max_concurrent_uploads": 3,
        "chunk_size_mb": 10,
        "timeout_seconds": 300,
        "retry_attempts": 3,
        "throttle_cpu_percent": 80
    },

    "cloud_credentials": {
        "google_drive": {
            "credentials_file": "credentials.json",
            "token_file": "token.json",
            "folder_id": null
        },
        "onedrive": {
            "client_id": "",
            "client_secret": "",
            "tenant_id": "",
            "redirect_uri": "http://localhost:8080/callback"
        }
    },

    "web_interface": {
        "enabled": true,
        "port": 8080,
        "host": "localhost",
        "authentication": false,
        "username": "admin",
        "password": "backup123"
    },

    "logging": {
        "level": "INFO",
        "max_file_size_mb": 10,
        "backup_count": 5,
        "console_output": true
    }
}

# install.py - Script de Instala√ß√£o
#!/usr/bin/env python3

import os
import sys
import subprocess
import json
import shutil
from pathlib import Path

def check_python_version():
    """Verifica vers√£o do Python"""
    if sys.version_info < (3, 8):
        print("‚ùå Python 3.8 ou superior √© necess√°rio")
        sys.exit(1)
    print("‚úÖ Vers√£o do Python adequada")

def install_dependencies():
    """Instala depend√™ncias"""
    print("üì¶ Instalando depend√™ncias...")
    try:
        subprocess.check_call([
            sys.executable, "-m", "pip", "install", "-r", "requirements.txt"
        ])
        print("‚úÖ Depend√™ncias instaladas")
    except subprocess.CalledProcessError:
        print("‚ùå Erro ao instalar depend√™ncias")
        sys.exit(1)

def create_directories():
    """Cria diret√≥rios necess√°rios"""
    directories = [
        "logs",
        "backups",
        "config",
        "credentials"
    ]

    for directory in directories:
        Path(directory).mkdir(exist_ok=True)
        print(f"üìÅ Diret√≥rio criado: {directory}")

def setup_config():
    """Configura arquivos de configura√ß√£o"""
    if not os.path.exists("backup_config.json"):
        # Criar configura√ß√£o b√°sica
        config = {
            "source_directory": input("üìÇ Diret√≥rio de origem: "),
            "local_backup_directory": input("üíæ Diret√≥rio de backup local: "),
            "cloud_provider": "google_drive"
        }

        with open("backup_config.json", "w") as f:
            json.dump(config, f, indent=4)
        print("‚úÖ Configura√ß√£o criada")

def setup_service():
    """Configura servi√ßo do sistema (Linux)"""
    if sys.platform.startswith('linux'):
        service_content = f"""[Unit]
Description=Sistema de Backup
After=network.target

[Service]
Type=simple
User={os.getenv('USER')}
WorkingDirectory={os.getcwd()}
ExecStart={sys.executable} main.py --action schedule --daemon
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
"""

        service_path = f"/etc/systemd/system/backup-system.service"
        try:
            with open(service_path, 'w') as f:
                f.write(service_content)

            subprocess.run(["sudo", "systemctl", "daemon-reload"])
            subprocess.run(["sudo", "systemctl", "enable", "backup-system"])

            print("‚úÖ Servi√ßo configurado (execute: sudo systemctl start backup-system)")
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao configurar servi√ßo: {e}")

def main():
    print("üöÄ Instalando Sistema de Backup")
    print("=" * 40)

    check_python_version()
    install_dependencies()
    create_directories()
    setup_config()

    if input("Configurar como servi√ßo do sistema? (s/N): ").lower() == 's':
        setup_service()

    print("\n‚úÖ Instala√ß√£o conclu√≠da!")
    print("üîß Execute: python main.py --help para ver op√ß√µes")

if __name__ == "__main__":
    main()

# backup_cli.py - Interface de Linha de Comando Avan√ßada
#!/usr/bin/env python3

import click
import json
from datetime import datetime
from pathlib import Path
from backup_restore import BackupRestorer
from monitoring import SystemMonitor

@click.group()
@click.option('--config', default='backup_config.json', help='Arquivo de configura√ß√£o')
@click.pass_context
def cli(ctx, config):
    """Sistema de Backup - Interface de Linha de Comando"""
    ctx.ensure_object(dict)
    ctx.obj['config_file'] = config

    # Carregar configura√ß√£o
    if Path(config).exists():
        with open(config) as f:
            ctx.obj['config'] = json.load(f)
    else:
        ctx.obj['config'] = {}

@cli.command()
@click.option('--type', 'backup_type', type=click.Choice(['full', 'incremental']),
              default='full', help='Tipo de backup')
@click.option('--compress/--no-compress', default=True, help='Comprimir backup')
@click.option('--encrypt/--no-encrypt', default=False, help='Criptografar backup')
@click.pass_context
def backup(ctx, backup_type, compress, encrypt):
    """Executa backup"""
    click.echo(f"üîÑ Executando backup {backup_type}...")

    # Aqui integraria com BackupManager
    click.echo(f"‚úÖ Backup {backup_type} conclu√≠do!")

@cli.command()
@click.pass_context
def list_backups(ctx):
    """Lista backups dispon√≠veis"""
    click.echo("üìã Backups Dispon√≠veis:")
    click.echo("-" * 50)

    # Integrar com BackupRestorer
    restorer = BackupRestorer(ctx.obj['config'])
    backups = restorer.list_available_backups()

    for backup in backups:
        size_mb = backup['size'] / (1024 * 1024)
        click.echo(f"üì¶ {backup['type']:12} | {backup['timestamp']} | {size_mb:.1f}MB")

@cli.command()
@click.argument('backup_path')
@click.argument('restore_path')
@click.option('--verify/--no-verify', default=True, help='Verificar integridade')
@click.pass_context
def restore(ctx, backup_path, restore_path, verify):
    """Restaura backup"""
    restorer = BackupRestorer(ctx.obj['config'])

    if verify:
        click.echo("üîç Verificando integridade...")
        if not restorer.verify_backup_integrity(backup_path):
            click.echo("‚ùå Backup corrompido!")
            return

    click.echo(f"üì• Restaurando {backup_path} para {restore_path}...")

    if restorer.restore_backup(backup_path, restore_path):
        click.echo("‚úÖ Restaura√ß√£o conclu√≠da!")
    else:
        click.echo("‚ùå Erro na restaura√ß√£o!")

@cli.command()
@click.pass_context
def status(ctx):
    """Mostra status do sistema"""
    monitor = SystemMonitor()
    info = monitor.get_system_info()
    warnings = monitor.check_system_health()

    click.echo("üìä Status do Sistema")
    click.echo("=" * 30)
    click.echo(f"üñ•Ô∏è  CPU: {info.get('cpu_percent', 0):.1f}%")
    click.echo(f"üíæ Mem√≥ria: {info.get('memory_percent', 0):.1f}%")
    click.echo(f"üíø Disco Livre: {info.get('disk_free_gb', 0):.1f}GB")

    if warnings:
        click.echo("\n‚ö†Ô∏è  Avisos:")
        for warning in warnings:
            click.echo(f"   ‚Ä¢ {warning}")
    else:
        click.echo("\n‚úÖ Sistema OK")

@cli.command()
@click.option('--start/--stop', help='Iniciar ou parar agendador')
@click.option('--daemon/--no-daemon', default=False, help='Executar em background')
@click.pass_context
def schedule(ctx, start, daemon):
    """Controla agendamento de backups"""
    if start:
        click.echo("üïê Iniciando agendador...")
        # Integrar com BackupScheduler
        click.echo("‚úÖ Agendador iniciado!")
    else:
        click.echo("üõë Parando agendador...")
        click.echo("‚úÖ Agendador parado!")

@cli.command()
@click.option('--days', default=30, help='Manter backups dos √∫ltimos N dias')
@click.option('--keep-full', default=4, help='Manter N backups completos')
@click.pass_context
def cleanup(ctx, days, keep_full):
    """Remove backups antigos"""
    click.echo(f"üßπ Removendo backups antigos (>{days} dias, mantendo {keep_full} completos)...")
    # Integrar com BackupManager.cleanup_old_backups()
    click.echo("‚úÖ Limpeza conclu√≠da!")

@cli.command()
@click.argument('destination')
@click.option('--provider', type=click.Choice(['google_drive', 'onedrive']),
              default='google_drive', help='Provedor de cloud')
@click.pass_context
def sync_cloud(ctx, destination, provider):
    """Sincroniza com servi√ßo de cloud"""
    click.echo(f"‚òÅÔ∏è  Sincronizando com {provider}...")
    # Integrar com CloudSyncManager
    click.echo("‚úÖ Sincroniza√ß√£o conclu√≠da!")

@cli.command()
@click.option('--format', 'output_format', type=click.Choice(['json', 'table', 'csv']),
              default='table', help='Formato de sa√≠da')
@click.pass_context
def report(ctx, output_format):
    """Gera relat√≥rio de backups"""
    click.echo("üìà Gerando relat√≥rio...")

    # Dados fict√≠cios para exemplo
    data = {
        "total_backups": 15,
        "full_backups": 4,
        "incremental_backups": 11,
        "total_size_gb": 125.6,
        "last_backup": "2025-01-15 14:30:00",
        "success_rate": 98.5
    }

    if output_format == 'json':
        click.echo(json.dumps(data, indent=2))
    elif output_format == 'table':
        click.echo("üìä Relat√≥rio de Backups")
        click.echo("=" * 30)
        click.echo(f"Total de backups: {data['total_backups']}")
        click.echo(f"Backups completos: {data['full_backups']}")
        click.echo(f"Backups incrementais: {data['incremental_backups']}")
        click.echo(f"Tamanho total: {data['total_size_gb']}GB")
        click.echo(f"√öltimo backup: {data['last_backup']}")
        click.echo(f"Taxa de sucesso: {data['success_rate']}%")

if __name__ == '__main__':
    cli()

# systemd_service_template.service
[Unit]
Description=Sistema de Backup Autom√°tico
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=backup
Group=backup
WorkingDirectory=/opt/backup-system
ExecStart=/usr/bin/python3 /opt/backup-system/main.py --action schedule --daemon
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
Restart=on-failure
RestartSec=5
TimeoutStopSec=30

# Vari√°veis de ambiente
Environment=PYTHONPATH=/opt/backup-system
Environment=BACKUP_CONFIG=/opt/backup-system/backup_config.json

# Recursos do sistema
MemoryMax=1G
CPUQuota=50%

# Logs
StandardOutput=journal
StandardError=journal
SyslogIdentifier=backup-system

[Install]
WantedBy=multi-user.target

# docker-compose.yml
version: '3.8'

services:
  backup-system:
    build: .
    container_name: backup-system
    restart: unless-stopped
    environment:
      - BACKUP_CONFIG=/app/config/backup_config.json
      - TZ=America/Sao_Paulo
    volumes:
      - ./config:/app/config
      - ./logs:/app/logs
      - ./data:/app/data
      - /caminho/para/origem:/app/source:ro
      - /caminho/para/backup:/app/backup
      - ./credentials:/app/credentials
    networks:
      - backup-net
    healthcheck:
      test: ["CMD", "python", "health_check.py"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Opcional: Interface web separada
  backup-web:
    build:
      context: .
      dockerfile: Dockerfile.web
    container_name: backup-web
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - BACKUP_API_URL=http://backup-system:8000
    depends_on:
      - backup-system
    networks:
      - backup-net

  # Opcional: Banco de dados para logs e metadados
  backup-db:
    image: postgres:13-alpine
    container_name: backup-db
    restart: unless-stopped
    environment:
      - POSTGRES_DB=backup_system
      - POSTGRES_USER=backup
      - POSTGRES_PASSWORD=backup_secure_password
    volumes:
      - backup_db_data:/var/lib/postgresql/data
    networks:
      - backup-net

networks:
  backup-net:
    driver: bridge

volumes:
  backup_db_data:

# Dockerfile
FROM python:3.11-slim

# Instalar depend√™ncias do sistema
RUN apt-get update && apt-get install -y \
    cron \
    rsync \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Criar usu√°rio n√£o-root
RUN useradd --create-home --shell /bin/bash backup

# Definir diret√≥rio de trabalho
WORKDIR /app

# Copiar requirements e instalar depend√™ncias Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiar c√≥digo da aplica√ß√£o
COPY --chown=backup:backup . .

# Criar diret√≥rios necess√°rios
RUN mkdir -p /app/{logs,config,credentials,data} && \
    chown -R backup:backup /app

# Mudar para usu√°rio n√£o-root
USER backup

# Expor porta para interface web (opcional)
EXPOSE 8080

# Comando padr√£o
CMD ["python", "main.py", "--action", "schedule", "--daemon"]

# health_check.py
#!/usr/bin/env python3

import sys
import os
import json
import requests
from datetime import datetime, timedelta

def check_backup_system():
    """Verifica sa√∫de do sistema de backup"""
    try:
        # Verificar se arquivo de configura√ß√£o existe
        if not os.path.exists('backup_config.json'):
            print("‚ùå Arquivo de configura√ß√£o n√£o encontrado")
            return False

        # Verificar logs recentes
        log_file = 'logs/backup.log'
        if os.path.exists(log_file):
            # Verificar se h√° logs recentes (√∫ltimas 24h)
            stat = os.stat(log_file)
            last_modified = datetime.fromtimestamp(stat.st_mtime)
            if datetime.now() - last_modified > timedelta(hours=24):
                print("‚ö†Ô∏è  Logs n√£o atualizados nas √∫ltimas 24h")
                return False

        # Verificar metadados de backup
        metadata_file = 'backup_metadata.json'
        if os.path.exists(metadata_file):
            with open(metadata_file) as f:
                metadata = json.load(f)

            # Verificar √∫ltimo backup
            last_backup = metadata.get('last_incremental_backup')
            if last_backup:
                last_backup_date = datetime.fromisoformat(last_backup.replace('Z', '+00:00'))
                if datetime.now() - last_backup_date > timedelta(days=2):
                    print("‚ö†Ô∏è  √öltimo backup h√° mais de 2 dias")
                    return False

        print("‚úÖ Sistema de backup saud√°vel")
        return True

    except Exception as e:
        print(f"‚ùå Erro na verifica√ß√£o: {e}")
        return False

if __name__ == "__main__":
    if not check_backup_system():
        sys.exit(1)
    sys.exit(0)

# requirements_extended.txt
# Depend√™ncias principais
google-api-python-client>=2.0.0
google-auth-httplib2>=0.1.0
google-auth-oauthlib>=0.8.0
schedule>=1.2.0
requests>=2.25.0
watchdog>=2.1.0

# Criptografia
cryptography>=3.4.8
pycryptodome>=3.15.0

# Interface CLI
click>=8.0.0
rich>=10.0.0  # Para sa√≠da colorida e formatada

# Monitoramento e sistema
psutil>=5.8.0
py-cpuinfo>=8.0.0

# Compress√£o avan√ßada
py7zr>=0.16.0  # Para arquivos 7z
rarfile>=4.0   # Para arquivos RAR

# Banco de dados (opcional)
sqlite3  # Inclu√≠do no Python
sqlalchemy>=1.4.0  # Para ORM se necess√°rio

# Web interface
flask>=2.0.0
flask-cors>=3.0.10

# Testes
pytest>=6.0.0
pytest-cov>=2.12.0

# Desenvolvimento
black>=21.0.0  # Formatador de c√≥digo
flake8>=3.9.0  # Linter

# run_tests.py
#!/usr/bin/env python3

import unittest
import sys
import os
from pathlib import Path

# Adicionar diret√≥rio raiz ao path
sys.path.insert(0, str(Path(__file__).parent))

class TestBackupSystem(unittest.TestCase):

    def setUp(self):
        """Configura√ß√£o para cada teste"""
        self.test_config = {
            "source_directory": "/tmp/test_source",
            "local_backup_directory": "/tmp/test_backup",
            "compression": True
        }

        # Criar diret√≥rios de teste
        os.makedirs(self.test_config["source_directory"], exist_ok=True)
        os.makedirs(self.test_config["local_backup_directory"], exist_ok=True)

    def test_config_loading(self):
        """Testa carregamento de configura√ß√£o"""
        from config import BackupConfig

        config = BackupConfig()
        self.assertIsNotNone(config.config)
        self.assertIn('source_directory', config.config)

    def test_file_hash_calculation(self):
        """Testa c√°lculo de hash de arquivos"""
        from backup_manager import BackupManager

        # Criar arquivo de teste
        test_file = os.path.join(self.test_config["source_directory"], "test.txt")
        with open(test_file, 'w') as f:
            f.write("Conte√∫do de teste")

        manager = BackupManager(self.test_config)
        hash1 = manager.calculate_file_hash(test_file)
        hash2 = manager.calculate_file_hash(test_file)

        self.assertEqual(hash1, hash2)
        self.assertIsNotNone(hash1)

    def test_exclude_patterns(self):
        """Testa exclus√£o de arquivos por padr√µes"""
        from backup_manager import BackupManager

        config = self.test_config.copy()
        config['exclude_patterns'] = ['*.tmp', '*.log']

        manager = BackupManager(config)

        self.assertTrue(manager.should_exclude_file('/path/arquivo.tmp'))
        self.assertTrue(manager.should_exclude_file('/path/sistema.log'))
        self.assertFalse(manager.should_exclude_file('/path/documento.txt'))

    def tearDown(self):
        """Limpeza ap√≥s cada teste"""
        import shutil

        # Remover diret√≥rios de teste
        for directory in [self.test_config["source_directory"],
                         self.test_config["local_backup_directory"]]:
            if os.path.exists(directory):
                shutil.rmtree(directory)

if __name__ == '__main__':
    # Executar testes
    unittest.main(verbosity=2)